---
title: "Uncertainty in the Assignment-Control space"
author: "Rachael Caelie (Rocky) Aikens"
date: "1/15/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, warning = FALSE, message = FALSE, echo = FALSE, fig.align = "center")
library(RACplots)
library(tidyverse)
library(ggpubr)
library(optmatch)
library(DOS2)

theme_set(theme_light())
```

# Plot uncertainty

In reality, when we make assignment-control plots, we rely on _estimated_ prognostic scores.  We might imagine in reality that every point has some "confidence ellipse" around it describing where its likely location is in 3 dimensional space.

## Confidence Intervals

One shorthand solution is to visualize the prediction intervals about each point calculated from the models for prognosis and propensity.  Problem here is that prediction intervals for logistic regression models don't really make sense.  So that won't work.
 
```{r}
# like prognostic match except returns data frame and match assignments, not just the
# reformatted dataframe of outcomes by match assignment
caliper_match_assignment <- function(df, propensity, match_assignment, prog_model, n_control) {
  df$m <- match_assignment
  df$row <- 1:nrow(df)
  n_t<- sum(df$t)

  selected <- df %>% 
    filter(!is.na(m)) %>%
    filter(t==0) %>%
    group_by(m) %>%
    sample_n(size = 1)
  
  prognostic <- lm(prog_model, data = selected)
  not_selected <- df[-selected$row, ]
  not_selected <- not_selected %>% 
			mutate(prog = predict(prognostic, not_selected)) %>%
			mutate(prop = predict(propensity, not_selected))
  
  mahal_dist <- match_on(formula(t ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10),
                         method = "mahalanobis", data = not_selected)
  mahal_caliper_dist <- addcaliper(mahal_dist, z = not_selected$t, p = not_selected$prop, caliper = 0.1)
  mahal_caliper_dist <- addcaliper(mahal_caliper_dist, z = not_selected$t, p = not_selected$prog, caliper = 0.1)
  m_caliper_match <- pairmatch(mahal_caliper_dist, controls = k, not_selected) 
  return(list(df = not_selected, match = m_caliper_match, k = n_control, prognostic = prognostic))
}

# splits and fits
split_n_fit <- function(df, propensity, match_assignment, prog_model) {
  df$m <- match_assignment
  df$row <- 1:nrow(df)
  n_t<- sum(df$t)

  selected <- df %>% 
    filter(!is.na(m)) %>%
    filter(t==0) %>%
    group_by(m) %>%
    sample_n(size = 1)
  
  prognostic <- lm(prog_model, data = selected)
  not_selected <- df[-selected$row, ]
  not_selected <- not_selected %>% 
			mutate(prog = predict(prognostic, not_selected)) %>%
			mutate(prop = predict(propensity, not_selected))
  
  return(not_selected)
}
```

```{r}
rho <- 0.5
#simulate data
df <- generate_data(N = 5000, p = 10, true_mu = "X1/3-2", rho = rho, sigma = 1)
k = 1
prop_model = formula(t ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10)
prog_model = formula(y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10)

# mahalanobis match
mahal_dist <- DOS2::smahal(df$t, df[,1:10])
m_match <- pairmatch(mahal_dist, controls = k, df)

# build propensity score
propensity <- glm(prop_model, family = binomial(), data = df)
  
prop_match <- pairmatch(propensity, controls = k, df)
  
# 1:2 mahalanobis matching to select data to use for prognostic model
mahal_match <- pairmatch(mahal_dist, controls = 2, df) 
  
caliper_match <- caliper_match_assignment(df, propensity, mahal_match, prog_model, k)
prognostic <- caliper_match$prognostic
```

```{r}
AC_plot2 <- function(data, title = "", shaded = 0){
  plt_data <- data %>%
    mutate(t = as.factor(t), a = as.factor(t == shaded)) %>%
    dplyr::select(c(t, prog, prop, a))
  
  plt <- ggplot(data = plt_data, aes( x = prop, y = prog, group = t, color = t)) + 
    geom_point(size = 1, aes(alpha = a)) +
    scale_alpha_manual(values = c(0.5, 1)) +
    scale_color_brewer(palette="Set1", direction = -1) +
    ggtitle(title) +
    theme(legend.position = "none", aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 9))+
    ylab(expression(paste("Prognosis, ", Psi, "(x)", sep = ""))) +
    xlab(expression(paste("Propensity, ", phi, "(x)", sep = "")))
  
  return(plt)
}

AC_plot_uncertainty <- function(data, title = "", shaded = 0){
  plt_data <- data %>%
    mutate(t = as.factor(t), a = as.factor(t == shaded)) %>%
    dplyr::select(c(t, prog, prop, a, prog_lwr, prog_upr, prop_lwr, prop_upr))
  
  plt <- ggplot(data = plt_data, aes( x = prop, y = prog, group = t, color = t)) + 
    geom_point(size = 1, aes(alpha = a)) +
    scale_color_brewer(palette="Set1", direction = -1) +
    ggtitle(title) +
    scale_alpha_manual(values = c(0.5, 0.5)) +
    theme(legend.position = "none", aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 9))+
    ylab(expression(paste("Prognosis, ", Psi, "(x)", sep = ""))) +
    xlab(expression(paste("Propensity, ", phi, "(x)", sep = ""))) +
    geom_errorbar(aes(ymin=prog_lwr, ymax=prog_upr, alpha = a), width = 0) +
    geom_errorbarh(aes(xmin=prop_lwr, xmax=prop_upr, alpha = a), height = 0)
  
  return(plt)
}
```

```{r}
a_set <- caliper_match$df

prog_intervals <- predict(caliper_match$prognostic, a_set, interval = "prediction")
prop_intervals <- predict(propensity, a_set, se.fit = T)
a_set <- a_set %>%
  mutate(prog = prog_intervals[,1],
         prog_lwr = prog_intervals[,2],
         prog_upr = prog_intervals[,3],
         prop = prop_intervals[[1]]) %>%
  mutate(prop_lwr = prop - prop_intervals[[2]],
         prop_upr = prop + prop_intervals[[2]])

a_set_subsample <- a_set %>%
  group_by(t) %>%
  sample_frac(0.02)
  
AC_plot_uncertainty(a_set_subsample)
AC_plot2(a_set_subsample)
```


## Bootstrapping 

One way we might try to do this is bootstrapping.  Bootstrapping also gets a little weird because in some bootstrap iterations, a row might end up in the pilot set, and in others it might end up in the analysis set.  If we bootstrap with replacement, we could end up with more than one instance of the same observation in the dataset, so we could have the same observation (possibly more than once) in the pilot and analysis sets.

Another idea is to bootstrap with the selection of the pilot set fixed, but even this gets a little weird.  First of all, what does it really mean to bootstrap with the pilot set fixed?  Does that produce anything with statistical meaning? Second, you will still end up with the problem that the same individual may appear in the analysis set more than once.  Bootstrapping in general feels a little weird here because we're trying to estimate uncertainty around each point, not some summary statistic of the data.  

In the first plot below, we try to understand variability in the prognostic and propensity models by performing 10 iterations of:

1. Resample the whole data set with replacement

1. Fit the propensity model

1. Split the data into pilot and analysis sets

1. Fit the prognsotic model

1. Estimate the prognostic scores on the analysis set.

There's something weird about this that I don't like at all.  When we bootstrap with replacement, it is nearly certain that some data points get duplicated in the dataset.  Then, when we split the data via mahalanobis distance matching, those identical points will very likely be matched to each other and split into different datasets (pilot and analysis).  The way that this splitting procedure focuses in on duplicated observations makes me a bit uncomfortable about whether bootstrapping in this way actually makes any sense.

```{r}
boot_fit <- function(df,
                     prop_model = formula(t ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10), 
                     prog_model = formula(y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10),
                     k = 1){
  
  df <- sample_n(df, dim(df)[1], replace = TRUE)
  
  # mahalanobis match
  mahal_dist <- DOS2::smahal(df$t, df[,1:10])
  m_match <- pairmatch(mahal_dist, controls = k, df)
  
  # build propensity score
  propensity <- glm(prop_model, family = binomial(), data = df)
    
  prop_match <- pairmatch(propensity, controls = k, df)
    
  # 1:2 mahalanobis matching to select data to use for prognostic model
  mahal_match <- pairmatch(mahal_dist, controls = 2, df) 
    
  fitted_set <- split_n_fit(df, propensity, mahal_match, prog_model)
  
  return(fitted_set)
}
```

```{r}
NSIM <- 10
result_list <- replicate(NSIM, boot_fit(df), simplify = F) 
actual <- split_n_fit(df, propensity, mahal_match, prog_model)
rownums <- c(sapply(result_list, function(x) dim(x)[1]), dim(actual)[1])

sim_nums <- c()
for (i in c(1:NSIM, 0)){
  if(i == 0) {
    n <- dim(actual)[1]
    } else {n <- rownums[i]}
  sim_nums <- c(sim_nums, rep(i, each = n))
}


result <- do.call("rbind", result_list) %>% 
  rbind(actual) %>%
  mutate(sim_num = sim_nums)
```

Also, the plots look stupid.

```{r}
subsample <- actual %>%
  group_by(t) %>%
  sample_frac(0.01) %>%
  pull(row)

result %>%
  filter(row %in% subsample) %>%
  mutate(t = as.factor(t), a = as.factor(ifelse(sim_num == 0, 1, 0.9))) %>%
  dplyr::select(c(t, prog, prop, a, row)) %>%
  ggplot( aes( x = prop, y = prog, color = row)) + 
    geom_point(size = 1, aes(alpha = a)) +
    theme(legend.position = "none", aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 9))+
    scale_color_distiller(palette = "Spectral") + 
    scale_alpha_manual(values = c(0.2, 1)) + 
    ylab(expression(paste("Prognosis, ", Psi, "(x)", sep = ""))) +
    xlab(expression(paste("Propensity, ", phi, "(x)", sep = "")))

result %>%
  filter(row %in% subsample) %>%
  mutate(t = as.factor(t), a = as.factor(ifelse(sim_num == 0, 1, 0.9))) %>%
  dplyr::select(c(t, prog, prop, a, row)) %>%
  ggplot(aes( x = prop, y = prog, color = t)) + 
    geom_point(size = 1, aes(alpha = a)) +
    theme(legend.position = "none", aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 9))+
    scale_color_brewer(palette = "Set1", direction = -1) + 
    scale_alpha_manual(values = c(0.2, 1)) + 
    ylab(expression(paste("Prognosis, ", Psi, "(x)", sep = ""))) +
    xlab(expression(paste("Propensity, ", phi, "(x)", sep = "")))
  
```

## Comparing actual and oracle

```{r}
rho <- 0.5
#simulate data
df <- generate_data(N = 2000, p = 10, true_mu = "X1/3-2", rho = rho, sigma = 1)

k = 1
prop_model = formula(t ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10)
prog_model = formula(y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10)

# mahalanobis match
mahal_dist <- DOS2::smahal(df$t, df[,1:10])
m_match <- pairmatch(mahal_dist, controls = k, df)

# build propensity score
propensity <- glm(prop_model, family = binomial(), data = df)
  
# 1:2 mahalanobis matching to select data to use for prognostic model
mahal_match <- pairmatch(mahal_dist, controls = 2, df) 

actual <- split_n_fit(df, propensity, mahal_match, prog_model)

oracle <- actual %>%
  mutate(prog = rho * X1 + sqrt(1 - rho ^ 2) * X2,
         prop = X1/3-2)

long_df <- rbind(actual, oracle) %>%
  mutate(type = rep(c("Estimated", "Oracle"), each = dim(actual)[1]), 
         t = as.factor(t))

subsample <- actual %>%
  group_by(t) %>%
  sample_frac(0.05) %>%
  pull(row)

pairs_data <- actual %>%
  mutate(prog_oracle = rho * X1 + sqrt(1 - rho ^ 2) * X2,
         prop_oracle = X1/3-2) %>%
  filter(row %in% subsample) %>%
  mutate(t = as.factor(t))

long_df %>%
  filter(row %in% subsample) %>%
ggplot( aes( x = prop, y = prog, color = t)) + 
  geom_point(size = 1, aes(alpha = type)) +
  theme( aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 9)) +
  geom_segment(data = pairs_data, 
                 aes(x = prop, y = prog,
                     xend = prop_oracle, yend = prog_oracle), color = "black", linetype = "dashed", alpha = 0.2) +
  scale_color_brewer(palette = "Set1", direction = -1)+
  scale_alpha_manual(values = c(0.5, 1)) + 
  ylab(expression(paste("Prognosis, ", Psi, "(x)", sep = ""))) +
  xlab(expression(paste("Propensity, ", phi, "(x)", sep = "")))

long_df %>%
  filter(row %in% subsample) %>%
ggplot( aes( x = prop, y = prog, color = t)) + 
  geom_point(size = 1, aes(alpha = type)) +
  theme(aspect.ratio=1, plot.title = element_text(hjust = 0.5, size = 9)) +
  scale_color_brewer(palette = "Set1", direction = -1)+
  scale_alpha_manual(values = c(0.4, 1)) + 
  ylab(expression(paste("Prognosis, ", Psi, "(x)", sep = ""))) +
  xlab(expression(paste("Propensity, ", phi, "(x)", sep = "")))
```

